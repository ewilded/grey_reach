# Grey Reach BurpSuite Professional plugin, written by Julian Horoszkiewicz and Grok 3
# A plugin aimed at deepening the coverage of blackbox/greybox tests by reaching non-default conditional blocks.
# https://github.com/ewilded/grey_reach
# https://hackingiscool.pl/reaching_non-default_conditional_blocks_during_grey_and_blackbox_webapp_testing
import re
import itertools
import random
from burp import IBurpExtender, IContextMenuFactory, ITab, IScannerInsertionPoint, IParameter, IScanIssue
from java.util import List, ArrayList
from jarray import array 
from java.lang import Boolean, Thread, System, Object
from javax.swing import JFrame, JPanel, JLabel, JTextArea, JButton, JScrollPane
from java.awt import BorderLayout, Dimension
        
class BurpExtender(IBurpExtender, IContextMenuFactory, ITab):
    def __init__(self):
        self.excluded_params = set()  # Store excluded params here
        self.last_action_time = 0
        self.debounce_ms = 200  # Ignore duplicate actions within 200ms to tackle the weird UI bug
    def registerExtenderCallbacks(self, callbacks):
        self._callbacks = callbacks
        self._helpers = callbacks.getHelpers()
        callbacks.setExtensionName("Grey Reach")
        callbacks.registerContextMenuFactory(self)
        callbacks.addSuiteTab(self)  # Register the custom tab
        print("Grey Reach loaded!")
        return

    def getTabCaption(self):
        return "Grey Reach config"
    def getUiComponent(self):
        panel = JPanel(BorderLayout())
        
        # Instructions
        label = JLabel("Enter parameters to exclude (one per line):")
        panel.add(label, BorderLayout.NORTH)
        
        # Text area for excluded params
        self.text_area = JTextArea(10, 30)
        self.text_area.setText("param1\nparam2")  # Example default
        scroll_pane = JScrollPane(self.text_area)
        panel.add(scroll_pane, BorderLayout.CENTER)
        
        # Save button
        save_button = JButton("Save exclusions", actionPerformed=self.saveExclusions)
        panel.add(save_button, BorderLayout.SOUTH)
        
        return panel
    def saveExclusions(self, event):
        lines = self.text_area.getText().splitlines()
        self.excluded_params = set(line.strip() for line in lines if line.strip())
        #print("DEBUG: Saved excluded params: {}".format(self.excluded_params))
        
    # Context menu
    def createMenuItems(self, invocation):
        from javax.swing import JMenuItem
        menu_list = ArrayList()
        
        flat_scan_item = JMenuItem("Flip Parameters - Flat Scan")
        flat_scan_item.addActionListener(lambda e: self.flipAndScan(e, invocation, mode="flat"))
        menu_list.add(flat_scan_item)
        
        deep_scan_item = JMenuItem("Flip Parameters - Deep Scan")
        deep_scan_item.addActionListener(lambda e: self.flipAndScan(e, invocation, mode="deep"))
        menu_list.add(deep_scan_item)
        
        return menu_list if menu_list.size() > 0 else None
        
    def flipAndScan(self, event, invocation, mode="flat"):
        #print("DEBUG: flipAndScan called! Mode={}, Messages={}, EventType={}, EventSource={}".format(mode, len(invocation.getSelectedMessages()), event.getID(), event.getSource()))
        current_time = System.currentTimeMillis()
        if current_time - self.last_action_time < self.debounce_ms: #had to introduce this to handle duplicate events generated by single menu item clicks, an unexpected behavior of Jython and Swing
            #print("DEBUG: Debounced duplicate action event")
            return
        self.last_action_time = current_time        
        http_messages = invocation.getSelectedMessages()
        if not http_messages or len(http_messages) == 0:
            print("No message selected!")
            return

        base_message = http_messages[0]
        request_info = self._helpers.analyzeRequest(base_message)
        base_request = base_message.getRequest()
        parameters = request_info.getParameters()
        if not parameters:
            print("No parameters found in the request!")
            return

        # Use excluded params from the tab
        params_to_flip = [p for p in parameters if p.getName() not in self.excluded_params]
        print("DEBUG: Params to flip: {}".format([p.getName() for p in params_to_flip]))

        if mode == "flat":
            self.flatScan(base_request, base_message, params_to_flip)
        elif mode == "deep":
            self.deepScan(base_request, base_message, params_to_flip, parameters)

    def getFlippedValues(self, original_value):
        flipped_values = [original_value]
        if original_value.lower() == "true":
            flipped_values.append("false")
            return flipped_values
        if original_value.lower() == "false":
            flipped_values.append("true")
            return flipped_values
        if original_value.isdigit():
            if original_value=="0":
                flipped_values.append("1")
                flipped_values.append("-1")
                return flipped_values
            if int(original_value)>0:
                flipped_values.append("0")
                flipped_values.append("-1")
                return flipped_values
        pattern = r'^-?\d+$'
        if(re.match(pattern, original_value)): # we're dealing with a negative number, which could happen as well
                flipped_values.append("0")
                flipped_values.append("1")
                return flipped_values
        # now, if we have reached this spot, we are assuming to simply provide a value that says "nondefault"; would be nice to improve this by e.g. allowing the user to specify the list of acceptable values for a parameter if they happen to know it, and use this "nondefault" one as default (no pun intended) when no such list is specified for the current parameter
        flipped_value = "nondefault"
        if original_value == flipped_value:
                number = random.randint(1, 1000) 
                flipped_value = "nondefault"+str(number)
        flipped_values.append(flipped_value)
        return flipped_values

    def flatScan(self, base_request, base_message, parameters):
        new_requests = []
        #new_requests.append(base_request) # actually we don't need the original base request to reach top-level blocks in flat mode, it's redundant
        for param in parameters:
            param_name = param.getName()
            param_value = param.getValue()
            param_type = param.getType()
            flipped_values = self.getFlippedValues(param_value)[1:]

            for flipped_value in flipped_values:
                new_request = self._helpers.updateParameter(
                    base_request,
                    self._helpers.buildParameter(param_name, flipped_value, param_type)
                )
                new_requests.append(new_request)

        total_requests = len(new_requests)
        print("Flat Scan: Generated {} new base requests.".format(total_requests))
        self.scheduleScans(base_message, new_requests)

    def deepScan(self, base_request, base_message, params_to_flip, all_params):
        param_names = [param.getName() for param in params_to_flip]
        param_types = [param.getType() for param in params_to_flip]
        value_sets = [self.getFlippedValues(param.getValue()) for param in params_to_flip]

        # Calculate total requests
        total_requests = 1
        for value_set in value_sets:
            total_requests *= len(value_set)
        print("Deep Scan: Total possible new base requests = {}".format(total_requests))

        # Generate combinations for flippable params
        new_requests = []
        # we don't manually add the original base request here, as it will be covered by set generation below
        for combo in itertools.product(*value_sets):
            new_request = base_request
            for i, value in enumerate(combo):
                new_request = self._helpers.updateParameter(
                    new_request,
                    self._helpers.buildParameter(param_names[i], value, param_types[i])
                )
            new_requests.append(new_request)

        print("Deep Scan: Generated {} new base requests.".format(len(new_requests)))
        self.scheduleScans(base_message, new_requests)

    def scheduleScans(self, base_message, new_requests):
        http_service = base_message.getHttpService()
        for i, new_request in enumerate(new_requests):
            # Analyze the request to get parameter offsets
            request_info = self._helpers.analyzeRequest(new_request)
            parameters = request_info.getParameters()
            params_to_flip = [p for p in parameters if p.getName() not in self.excluded_params]

            # Build insertion point offsets
            insertion_point_offsets = ArrayList()
            for param in params_to_flip:
                start = param.getValueStart()
                end = param.getValueEnd()
                offsets = array([start, end], 'i')  # int[] with start and end positions
                insertion_point_offsets.add(offsets)
                print("DEBUG: Added offsets for {}: [{},{}]".format(param.getName(), start, end))

            print("DEBUG: Scheduling scan #{} with {} insertion points".format(i + 1, insertion_point_offsets.size()))
            scan_id = self._callbacks.doActiveScan(
                http_service.getHost(),
                http_service.getPort(),
                http_service.getProtocol() == "https",
                new_request,
                insertion_point_offsets
            )
            print("DEBUG: Scan #{} scheduled with ID: {}".format(i + 1, scan_id))
        print("All scans scheduled!")
if __name__ in ('__main__', 'burp'):
    BurpExtender()